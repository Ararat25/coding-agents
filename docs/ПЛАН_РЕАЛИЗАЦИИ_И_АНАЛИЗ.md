# Детальный анализ задачи и план реализации SDLC Coding Agents

**Роль:** Senior Python разработчик (10+ лет)  
**Принципы:** Clean Code, отсутствие дублирования, применение паттернов где уместно.

---

## 1. Сводка задачи

Необходимо реализовать **агентную систему**, имитирующую полный цикл разработки (SDLC) внутри GitHub:

- **Code Agent** — читает Issue, меняет код, создаёт PR (CLI + опционально API).
- **AI Reviewer Agent** — анализирует PR (diff, CI), сравнивает с Issue, публикует review.
- Цикл: Issue → Code Agent → PR → CI/CD → Reviewer → комментарии → при замечаниях новый цикл правок до успеха или лимита итераций.

Всё взаимодействие — через **GitHub**: Issues, Pull Requests, GitHub Actions (и/или webhook).

---

## 2. Ключевые выводы из ответов менторов

| Вопрос / тема | Ответ ментора | Влияние на дизайн |
|---------------|----------------|-------------------|
| **Взаимодействие с продуктом** | Агент в облаке/локально (Docker), туннель или GitHub App; Code Agent пишет код → Reviewer ревьюит; несколько циклов до решения; тесты не должны ломаться; CI/CD не должен фейлиться если изначально рабочий | Нужен лимит итераций, проверка что правки не ломают существующие тесты |
| **Наличие pipeline (тесты/линтеры)** | Не обязательно — агенту может быть дана задача добавить pre-commit и линтеры | Code Agent и Reviewer должны уметь работать с репо без готового CI; при необходимости агент может предлагать/добавлять конфиги |
| **Нормализация по моделям (GigaChat vs GPT)** | Желательно подстановка API-ключа в проекте для проверки на разных моделях | Абстракция LLM-провайдера (Strategy/Factory), конфиг через env |
| **OpenHands и т.п.** | Нужна своя реализация | Не использовать готовые агентские фреймворки для core-логики |
| **CLI vs API** | CLI изначально входит; при хостинге в облаке можно по API, можно убрать оболочку CLI | Реализовать core без привязки к CLI; CLI и API — тонкие слои над одним движком |
| **Любой репо / форк** | В плане-максимум — работа с любым репо; форк можно вручную | Не обязательно автоматический форк; достаточно: репо URL + branch + issue number (или ручной форк) |
| **Интеграция с GitHub** | Важнее core AI-фича; с любым репо без правок CI не обязательно; через GitHub App — плюс, минимум инфры на целевом репо | Два режима: 1) «тяжёлый» — GitHub App + webhook, 2) «лёгкий» — workflow в нашем репо + вызов агента (в т.ч. по ссылке на issue) |
| **Reviewer: в Actions или на сервере?** | Выполнение может быть где угодно; взаимодействие — webhook + GitHub API; за облако — доп. баллы | Reviewer можно запускать в Actions (job) или на нашем сервере по webhook; единый контракт: вход (PR, diff, CI results, Issue), выход (комментарий/summary/review) |
| **Верификация Issue** | Фильтрация (например, лейбл ready-to-code) — плюс; улучшение промпта/Issue — плюс | Опционально: фильтр по лейблам/assignee; опционально — шаг «улучшение формулировки Issue» перед кодом |
| **Workflow при создании Issue** | Две части: генерация кода (Code Agent) и создание PR; PR запускает цикл Actions + review + правки | Workflow на `issues: types: [opened]` может вызывать Code Agent; отдельно workflow на `pull_request` — запуск Reviewer (и при необходимости триггер следующей итерации) |
| **Один бот: и код, и review, и merge?** | Должны быть **две изолированные стороны** — чтобы Code Agent не продвигал сам себе решение; GitHub App может быть один | Логически два агента (Code / Reviewer), два набора ролей в промптах и в коде; один App — ок, но «лица» в review и в коммитах/PR должны быть разведены (разные bot-аккаунты или явные метки в комментариях) |
| **Вебхук** | Полноценный webhook (endpoint для GitHub) даёт более высокий балл | Реализовать HTTP endpoint для событий `issues`, `pull_request`, `check_suite`/`workflow_run` при необходимости; валидация подписи (X-Hub-Signature-256) |
| **Мердж / деплой** | Не входят в задание; достаточно unit-тестов; все чеки должны проходить; код должен быть рабочим | Не реализовывать авто-merge и деплой; критерий готовности — все проверки зелёные, review пройден |

Эти пункты нужно учитывать при проектировании компонентов, контрактов и сценариев.

---

## 3. Технические требования (напоминание)

- **Python 3.11+**
- **LLM:** GPT-4o-mini, YandexGPT или эквивалент (с возможностью подстановки ключа).
- **GitHub:** GitPython или PyGithub.
- **Качество кода:** ruff, black, mypy, pytest.
- **CI/CD:** GitHub Actions.
- **Code Agent:** CLI-инструмент (ядро переиспользуемо для API).
- **Инфраструктура:** Dockerfile, зависимости и код в репо; `docker-compose up -d` поднимает сервис (или инструкция для локального запуска).

---

## 4. Архитектура решения (высокоуровнево)

### 4.1. Два «лица» системы

1. **Code Agent**  
   - Читает Issue (и при необходимости — предыдущие комментарии Reviewer).  
   - Планирует и генерирует изменения кода.  
   - Делает коммиты и создаёт/обновляет PR.  
   - Не принимает решений «принять своё же решение» — только пишет код и открывает/обновляет PR.

2. **AI Reviewer Agent**  
   - Запускается после появления/обновления PR (и при необходимости после завершения CI).  
   - Собирает: описание Issue, diff PR, результаты CI (statuses, check runs).  
   - Анализирует соответствие реализации Issue, качество кода, провалы CI.  
   - Публикует в PR: summary, комментарии к коду, общий вердикт (approved / changes_requested).  
   - Не вносит правки в код — только анализ и комментарии.

Связь между ними только через GitHub (Issue, PR, комментарии). Один GitHub App допустим, но логика и роли разделены.

### 4.2. Варианты триггеров

**Вариант A — только GitHub Actions (минимальный):**

- Workflow 1: на `issues: types: [opened]` (и опционально по лейблу) → запускает job, который вызывает Code Agent (например, через Docker или API нашего сервиса) с `repo`, `issue_number`.
- Workflow 2: на `pull_request: types: [opened, synchronize]` и при необходимости на `check_suite`/`workflow_run: completed` → запускает Reviewer (в том же или другом job).

**Вариант B — webhook (выше оценка):**

- Один HTTP endpoint (например, `/webhook/github`).
- Подписки: `issues` (opened), `pull_request` (opened, synchronize), при необходимости `check_suite` / `workflow_run` (completed).
- Валидация `X-Hub-Signature-256`.
- По событию — постановка задачи в очередь (или синхронно) и вызов соответствующего агента (Code или Reviewer).
- Результаты обратно в GitHub только через API (комментарии, review, status).

Имеет смысл спроектировать ядро так, чтобы оба варианта использовали одни и те же сервисы (Code Agent Service, Reviewer Agent Service).

### 4.3. Защита от бесконечных циклов

- **Жёсткий лимит итераций** на один Issue (например, 5): после N раундов (Reviewer оставил changes_requested и Code Agent уже делал правки N раз) — прекращаем, оставляем комментарий в Issue/PR.
- **Детекция повторяющихся выводов:** если последний review по смыслу совпадает с предыдущим (например, те же замечания) — считать один «повтор» и учитывать в лимите или останавливаться.
- **Таймауты:** на один запуск Code Agent и на один запуск Reviewer — ограничение по времени (и при необходимости по токенам LLM).
- Лимит и таймауты — конфигурируемые (env / config).

---

## 5. План реализации по шагам

### Фаза 0: Подготовка репозитория и инфраструктуры

- **0.1** Структура проекта (папки: `src/`, `tests/`, `docs/`, конфиги, Docker, docker-compose).  
- **0.2** Зависимости: `pyproject.toml` / `requirements.txt` — PyGithub (или GitPython), HTTP-клиент, вызов LLM (openai, yandex-cloud и т.д.), ruff, black, mypy, pytest.  
- **0.3** Конфигурация: env-переменные для API-ключей (LLM, GitHub token), лимитов итераций, таймаутов; один конфиг-модуль/класс.  
- **0.4** Dockerfile и docker-compose: сервис приложения (CLI + при необходимости web-сервер для webhook и API); инструкция локального запуска без Docker.

### Фаза 1: Работа с GitHub и контекстом

- **1.1** Абстракция доступа к GitHub (репозиторий, Issue, PR, комментарии, проверки CI).  
  - Интерфейс (Protocol/ABC): получить Issue по номеру, получить PR по ветке/номеру, получить diff, список check runs / statuses для коммита/PR.  
  - Реализация на PyGithub (или GitPython для локального клона + PyGithub для API).  
- **1.2** Сбор контекста для Reviewer: текст Issue, тело PR, diff (patch), список файлов, результаты CI (успех/провал, логи при необходимости в сжатом виде). Единая DTO/датакласс.  
- **1.3** Сбор контекста для Code Agent: текст Issue, опционально — последние комментарии Reviewer в PR, ссылка на репо и ветку.  
- **1.4** Публикация результатов Reviewer: создание комментария к PR, создание review (submit_review с body и event APPROVE / REQUEST_CHANGES / COMMENT). Использовать только API (PyGithub).

### Фаза 2: LLM и промпты

- **2.1** Абстракция LLM: интерфейс (например, `generate(prompt, system, max_tokens, ...) -> str` или структурированный вывод).  
- **2.2** Реализации провайдеров: OpenAI (GPT-4o-mini), Yandex (YandexGPT) — через единый интерфейс; выбор по конфигу.  
- **2.3** Промпты для Reviewer:  
  - Роль, вход (Issue, diff, CI results), формат вывода (summary, список замечаний с путём и строкой, вердикт: approved / changes_requested).  
  - Чёткие критерии: соответствие Issue, качество кода, провалы CI.  
- **2.4** Промпты для Code Agent:  
  - Роль, вход (Issue, опционально замечания Reviewer), структура репо (список файлов или ключевых модулей).  
  - Выход: пошаговый план и/или патчи/редактирования файлов (единый формат, например «файл + операции вставки/замены»).  
- **2.5** Парсинг ответов: из ответа Reviewer — извлечение summary, замечаний, вердикта; из ответа Code Agent — извлечение списка изменений файлов и применение их к репо (осторожно с экранированием и путями).

### Фаза 3: Code Agent (ядро)

- **3.1** Сервис Code Agent:  
  - Вход: repo_id (owner/name), issue_number, опционально branch, опционально pr_number (для итерации).  
  - Шаги: получить Issue → (опционально) получить комментарии Reviewer из связанного PR → вызвать LLM → распарсить план/патчи → применить изменения в локальном клоне (GitPython или команды git) → коммит → push → создать PR или обновить существующий.  
- **3.2** Работа с локальным клоном: клонирование (или обновление), создание ветки от base (main/master), применение изменений, коммит, push. Учёт токена (GitHub App или PAT).  
- **3.3** Связь Issue ↔ PR: по лейблу, по названию ветки (например, `issue-123`) или по первому комментарию с ссылкой на PR; хранить в сценарии итерации.  
- **3.4** Лимит итераций: перед запуском Code Agent проверять счётчик итераций по данному Issue (например, по метке в Issue или по количеству коммитов от бота в PR); при достижении лимита — не делать новый коммит, оставить комментарий в Issue.

### Фаза 4: AI Reviewer Agent (ядро)

- **4.1** Сервис Reviewer:  
  - Вход: repo_id, pr_number (или branch + base).  
  - Шаги: получить PR, связанный Issue (по ссылке в описании или по ветке), diff, CI results → собрать контекст → вызвать LLM → распарсить ответ → отправить review и/или комментарий в PR.  
- **4.2** Ожидание завершения CI (опционально): после `pull_request` можно ждать `check_suite`/`workflow_run` completed для head SHA, затем запускать Reviewer; либо запускать Reviewer сразу, а в промпте указывать «CI ещё в процессе» если статусов нет.  
- **4.3** Формат публикации: один summary-комментарий + один submit_review с телом и event (REQUEST_CHANGES / APPROVE). При необходимости — отдельные комментарии к строкам (pull request review comments API).

### Фаза 5: Оркестрация и сценарии

- **5.1** Сценарий «от Issue до готового PR»:  
  - Запуск Code Agent по Issue → создание PR → (вручную или по workflow) запуск Reviewer после CI → если changes_requested и итерации < N — постановка задачи на повторный запуск Code Agent с контекстом замечаний; иначе — конец (успех или исчерпан лимит).  
- **5.2** Триггер повторной итерации:  
  - Вариант через Actions: job «после review» вызывает наш сервис (API) с `issue_id`, `pr_id`, телом последнего review.  
  - Вариант через webhook: на событие `pull_request_review` (submitted) с `event: changes_requested` — проверять, что автор PR — наш бот, тогда вызвать Code Agent для следующей итерации.  
- **5.3** Идемпотентность и повторные запуски: при повторном срабатывании на то же Issue/PR не создавать второй PR и не дублировать комментарии (проверка по меткам или по уже существующему PR для Issue).

### Фаза 6: CLI и API

- **6.1** CLI (argparse или click):  
  - Команды вида: `run-code-agent --repo owner/name --issue 1 [--branch issue-1]`, `run-reviewer --repo owner/name --pr 2`.  
  - Опционально: `--dry-run` (не пушить, не создавать PR).  
- **6.2** API (FastAPI/Flask):  
  - POST `/code-agent/run` (repo, issue_number, …).  
  - POST `/reviewer/run` (repo, pr_number, …).  
  - POST `/webhook/github` (тело webhook, заголовки) — только для варианта с webhook.  
- **6.3** Общая точка входа: и CLI, и API вызывают одни и те же сервисы (Code Agent Service, Reviewer Service), без дублирования логики.

### Фаза 7: GitHub Actions workflows

- **7.1** Workflow «on issue opened»:  
  - `on: issues: types: [opened]` (и при необходимости фильтр по label).  
  - Job: checkout (если нужен скрипт), вызов CLI в контейнере или HTTP на наш сервис с `GITHUB_REPOSITORY`, `ISSUE_NUMBER`. Секреты: `GITHUB_TOKEN` или токен App.  
- **7.2** Workflow «on pull_request / check_suite»:  
  - Запуск Reviewer после открытия/обновления PR; при необходимости дождаться завершения check_suite для head.  
- **7.3** Документация: как подключить workflows к репо (скопировать yaml, добавить секреты); при webhook — как настроить GitHub App и URL.

### Фаза 8: Качество и валидация

- **8.1** Unit-тесты: парсинг ответов LLM (мок), применение патчей, сбор контекста GitHub (мок API).  
- **8.2** Интеграционные тесты: на тестовом репо с одним Issue и одним PR (мок LLM или маленькая модель).  
- **8.3** Ruff, black, mypy в CI самого проекта coding-agents.  
- **8.4** Валидация по заданию: тестовый репо с подготовленными Issues; проверка отсутствия бесконечных циклов, обработки ошибок, доли успешных задач и числа итераций; базовая проверка на уязвимости (ruff, bandit) и соответствие библиотек актуальным версиям.

### Фаза 9: Документация и сдача

- **9.1** README: назначение, архитектура (два агента), как запустить (Docker, локально), как подставить свой API ключ, как подключить workflows / webhook.  
- **9.2** Отчёт: сценарии работы, примеры Issues и PR, метрики (итерации, успех), ограничения.  
- **9.3** Опционально: деплой в облако (cloud.ru / Yandex Cloud) и описание доступа.

---

## 6. Паттерны и принципы (кратко)

- **Разделение ответственности:** Code Agent только пишет код и создаёт PR; Reviewer только анализирует и пишет review.  
- **Абстракции:** GitHub client (Protocol), LLM client (Protocol), конфиг (один источник правды).  
- **Единая точка бизнес-логики:** сервисы Code Agent и Reviewer не зависят от CLI/API; CLI и API — адаптеры.  
- **Ограничение итераций и таймаутов:** явно в конфиге и в оркестрации, не полагаться на LLM.  
- **Идемпотентность:** проверка «уже есть PR для этого Issue» и «уже была итерация N».  
- **Безопасность:** секреты только в env/secrets, валидация webhook по подписи, никаких хардкодов ключей.

---

## 7. Риски и смягчение

| Риск | Смягчение |
|------|------------|
| LLM возвращает непарсируемый вывод | Строгий формат в промпте (JSON/маркеры); fallback-парсинг; повтор с упрощённым промптом. |
| Слишком большие diff/контекст | Ограничение размера diff в токенах; суммаризация длинных файлов; только изменённые файлы. |
| CI в целевом репо нестабилен | Reviewer явно интерпретирует «часть проверок не прошла»; не блокировать вечный цикл только из-за flaky tests — использовать лимит итераций. |
| Разные версии Python/зависимостей в целевом репо | Code Agent не обязан менять окружение проекта; при добавлении тестов/линтеров — следовать конвенциям репо. |

---

## 8. Полезные материалы (уже использованные)

- GitHub: [Events that trigger workflows](https://docs.github.com/en/actions/using-workflows/triggering-a-workflow), [Webhook events and payloads](https://docs.github.com/en/webhooks/webhook-events-and-payloads).  
- Паттерны агентов: ReAct, Plan-and-Execute; внешние лимиты итераций и таймауты (не полагаться на «модель сама остановится»).  
- PyGithub: Pull Request, Issue, Review, Check Runs; создание комментариев и review через API.  
- Clean Architecture для AI: разделение домена, приложения и инфраструктуры (LLM, GitHub, файловая система) без жёсткой иерархии папок.

---

Этот документ можно использовать как чек-лист и основу для тикетов при реализации. Код писать на следующем этапе по этому плану, с приоритетом фаз 0–4 (инфраструктура, GitHub, LLM, оба агента), затем 5–7 (оркестрация, CLI/API, workflows), затем 8–9 (тесты, отчёт, деплой).
