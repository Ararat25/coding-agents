# Пошаговая инструкция: запуск и использование сервиса

## Что делает сервис

1. Ты даёшь ему **репозиторий GitHub** и **номер Issue**.
2. Сервис читает описание Issue, генерирует код (через LLM), пушит в новую ветку и создаёт **Pull Request**.
3. Потом запускается **Reviewer**: смотрит PR, результаты CI и оставляет review в PR.
4. Если review с замечаниями — цикл повторяется (до лимита итераций).

**Важно:** Репозиторий и Issue должны существовать в GitHub. Токен должен иметь доступ к этому репо.

---

## Шаг 1: Что нужно заранее

### 1.1 Репозиторий на GitHub

- Репозиторий существует (например `EgorovM/mega-ai-agent-observability`).
- В нём есть **Issue с нужным номером** (например Issue #42). Номер смотри в GitHub: вкладка Issues → у каждого issue есть номер.

**Не подходит:** ссылка на папку внутри репо (`/tree/main/coding-agent/test_project`). Сервис работает с **целым репозиторием** и его Issues.

### 1.2 GitHub токен

- Зайти: https://github.com/settings/tokens
- Create token (classic) или fine-grained.
- Права для **репозитория**, с которым будешь работать:
  - **repo** (полный доступ к репо) — для classic token;
  - или для fine-grained: Contents (Read and write), Pull requests (Read and write), Issues (Read and write), Metadata (Read).
- Скопировать токен и вставить в `.env` (см. ниже).

Токен должен быть от пользователя, у которого есть доступ к репо (владелец или collaborator). Для репо другого пользователя — токен этого пользователя или инсталляция GitHub App.

### 1.3 API ключ LLM

- Для OpenAI: https://platform.openai.com/api-keys → создать ключ, вписать в `.env` как `OPENAI_API_KEY`.
- Либо YandexGPT: тогда в `.env` указать `LLM_PROVIDER=yandex`, `YANDEX_API_KEY`, `YANDEX_FOLDER_ID`.

**Если OpenAI в твоей стране недоступен (403 unsupported_country_region_territory):** используй YandexGPT (см. [ОБХОД_ГЕО_ОГРАНИЧЕНИЙ_OPENAI.md](ОБХОД_ГЕО_ОГРАНИЧЕНИЙ_OPENAI.md)) или прокси/зеркало API.

---

## Шаг 2: Настройка .env

В **корне проекта** (рядом с `docker-compose.yml`) создай файл `.env`:

```bash
# Обязательно
GITHUB_TOKEN=ghp_xxxxxxxxxxxxxxxxxxxx
OPENAI_API_KEY=sk-proj-xxxxxxxxxxxxxxxxxxxx

# Какой LLM использовать
LLM_PROVIDER=openai

# Остальное можно не трогать
MAX_ITERATIONS=5
CODE_AGENT_TIMEOUT=300
REVIEWER_TIMEOUT=180
WEBHOOK_PORT=8000
LOG_LEVEL=INFO
```

- Не ставь комментарии в той же строке, что и значение (некоторые парсеры их не отрезают). Лучше так:
  - `LLM_PROVIDER=openai`
- Если используешь YandexGPT:
  - `LLM_PROVIDER=yandex`
  - `YANDEX_API_KEY=...`
  - `YANDEX_FOLDER_ID=...`

Файл `.env` должен лежать там же, где `docker-compose.yml`, чтобы контейнер его подхватил.

---

## Шаг 3: Запуск сервиса (Docker)

В корне проекта:

```bash
# Сборка без кеша (чтобы подтянуть последний код)
docker-compose build --no-cache

# Запуск
docker-compose up -d
```

Проверка, что сервис живой:

```bash
curl http://localhost:8000/health
```

Ожидаемый ответ: `{"status":"ok"}`.

Логи:

```bash
docker-compose logs -f
```

---

## Шаг 4: Что передавать в API

### Endpoint: `POST /api/process-issue`

Обрабатывает один Issue: создаёт ветку, код, PR и запускает Reviewer.

**URL:** `http://localhost:8000/api/process-issue`  
**Метод:** POST  
**Content-Type:** `application/json`

**Тело запроса:**

```json
{
    "repo": "EgorovM/mega-ai-agent-observability",
    "issue_number": 42,
    "start_iteration": 1
}
```

- **repo** — строго в формате **`владелец/имя-репо`** (одним словом — "owner/repo").  
  Примеры:
  - `EgorovM/mega-ai-agent-observability`
  - `octocat/Hello-World`  
  Можно также передать полный URL репо, сервис сам вырежет owner/repo, например:
  - `https://github.com/EgorovM/mega-ai-agent-observability`
  - `https://github.com/EgorovM/mega-ai-agent-observability/tree/main/coding-agent/test_project`  
  Внутри всё равно будет использоваться `EgorovM/mega-ai-agent-observability`.
- **issue_number** — целое число. В репозитории **должен существовать** Issue с таким номером (смотри в GitHub → Issues).
- **start_iteration** — с какой итерации начать, обычно `1`.

**Пример запроса (curl):**

```bash
curl -X POST http://localhost:8000/api/process-issue \
  -H "Content-Type: application/json" \
  -d '{"repo": "EgorovM/mega-ai-agent-observability", "issue_number": 42, "start_iteration": 1}'
```

**Пример успешного ответа:**

```json
{
    "success": true,
    "message": "Задача успешно выполнена. PR #123 одобрен.",
    "iteration": 1,
    "pr_number": 123
}
```

**Пример ошибки (404 — репо или Issue не найден):**

```json
{
    "success": false,
    "message": "Code Agent ошибка: Ошибка: 404 ...",
    "iteration": 1,
    "pr_number": null
}
```

---

## Почему может быть 404

1. **Неверный формат repo**  
   Должно быть именно `владелец/репо`, без `https://`, без `/tree/main/...`.  
   Если передаёшь URL — сервис сам нормализует; если 404 остаётся, проверь п.2 и п.3.

2. **Репозитория нет или имя другое**  
   Проверь в браузере: `https://github.com/EgorovM/mega-ai-agent-observability` — открывается? Имя и владелец должны совпадать с тем, что в запросе.

3. **Issue с таким номером не существует**  
   В репо `EgorovM/mega-ai-agent-observability` зайди в Issues и убедись, что есть, например, Issue #42. Номер указывай тот, что видишь в интерфейсе.

4. **Токен не имеет доступа к репо**  
   Для приватного репо токен должен быть от владельца или от пользователя с доступом. Для чужого публичного репо обычно достаточно своего токена с правами `repo` (classic) или аналогом для fine-grained.

5. **Контейнер собран со старым кодом**  
   После изменений в коде обязательно:
   ```bash
   docker-compose build --no-cache
   docker-compose up -d
   ```

---

## Проверка по шагам

1. **Репо и Issue**  
   В браузере:  
   `https://github.com/EgorovM/mega-ai-agent-observability/issues/42`  
   Если страница открывается — репо и Issue есть.

2. **Токен**  
   В другом терминале (или Postman):
   ```bash
   curl -H "Authorization: token ВАШ_GITHUB_TOKEN" \
     https://api.github.com/repos/EgorovM/mega-ai-agent-observability
   ```
   Должен вернуться JSON с полем `"name": "mega-ai-agent-observability"`. Если 404 — токену нет доступа к этому репо.

3. **Сервис и формат запроса**  
   ```bash
   curl -X POST http://localhost:8000/api/process-issue \
     -H "Content-Type: application/json" \
     -d '{"repo": "EgorovM/mega-ai-agent-observability", "issue_number": 42, "start_iteration": 1}'
   ```
   Сначала убедись, что в репо действительно есть Issue #42 и что используешь именно `owner/repo` без лишних символов.

---

## Автозапуск агентов при создании Issue (webhook)

**Да, такая возможность реализована.** При создании нового Issue в репозитории сервис может автоматически запускать обработку (Code Agent → PR → Reviewer), если настроен **webhook**.

Как это работает:
1. В репозитории GitHub (или в настройках GitHub App) указываешь **Webhook URL**: `https://твой-сервер:8000/webhook/github`.
2. Подписываешься на события: **issues** (opened), при необходимости **pull_request**, **check_suite**.
3. При создании Issue GitHub шлёт POST на этот URL; сервис вызывает `orchestrator.process_issue(repo, issue_number)` и обрабатывает Issue.

Что нужно:
- Сервис должен быть доступен из интернета (белый IP или туннель: ngrok, cloudflared и т.п.).
- В настройках webhook указать **Secret** и прописать его в `.env` как `WEBHOOK_SECRET` (для проверки подписи).
- Для репозитория: Settings → Webhooks → Add webhook → Payload URL, Content type `application/json`, события Issues (и при необходимости Pull requests).

Без webhook авто-запуск при создании Issue не происходит — только ручной вызов API или CLI.

---

## Краткий чеклист

- [ ] В GitHub есть репозиторий и Issue с нужным номером.
- [ ] Создан GitHub token с правами на этот репо.
- [ ] В корне проекта создан `.env` с `GITHUB_TOKEN` и `OPENAI_API_KEY` (или Yandex).
- [ ] Выполнены `docker-compose build --no-cache` и `docker-compose up -d`.
- [ ] `curl http://localhost:8000/health` возвращает `{"status":"ok"}`.
- [ ] В запросе `repo` = `владелец/имя-репо` (например `EgorovM/mega-ai-agent-observability`), `issue_number` = существующий номер Issue.

Если всё это выполнено и 404 всё равно есть — пришли точный JSON тела запроса и точный ответ сервера (или скрин), тогда можно разобрать точечно.
